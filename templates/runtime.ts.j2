{% if support_buffer %}
type BufferLike = Sink | Buffer | ArrayBuffer | Uint8Array;
{% else %}
type BufferLike = Sink | ArrayBuffer | Uint8Array;
{% endif %}

class Sink {
  public view: DataView;
  public pos: number;

  private constructor(input: ArrayBuffer) {
    this.view = new DataView(input);
    this.pos = 0;
  }

  public reserve(extra: number): void {
    if (this.pos + extra <= this.view.buffer.byteLength) {
      return;
    }

    const newBuffer = new ArrayBuffer(
      (this.view.buffer.byteLength + extra) * 2
    );

    new Uint8Array(newBuffer).set(new Uint8Array(this.view.buffer));
    this.view = new DataView(newBuffer);
  }

  public static create(input?: BufferLike): Sink {
    if (input == undefined) {
      return new Sink(new ArrayBuffer(0));
    }

    if (input instanceof Sink) {
      return input;
    }
{% if support_buffer %}
    if (input instanceof Buffer) {
      return new Sink(
        input.buffer.slice(
          input.byteOffset,
          input.byteOffset + input.byteLength
        )
      );
    }
{%- endif %}

    if (input instanceof ArrayBuffer) {
      return new Sink(input);
    }

    if (input instanceof Uint8Array) {
      return new Sink(input.buffer);
    }

    throw new Error(
{%- if support_buffer %}
      `'input' was of incorrect type. Expected 'Sink | Buffer | ArrayBuffer | Uint8Array'`
{%- else %}
      `'input' was of incorrect type. Expected 'Sink | ArrayBuffer | Uint8Array'`
{%- endif %}
    );
  }

  public getUint8Array(): Uint8Array {
    return new Uint8Array(this.view.buffer.slice(0, this.pos));
  }
{% if support_buffer %}
  public getBuffer(): Buffer {
    return Buffer.from(this.view.buffer, 0, this.pos);
  }
{%- endif %}
}

const BIG_32 = BigInt(32);
const BIG_64 = BigInt(64);
const BIG_32Fs = BigInt('4294967295');
const BIG_64Fs = BigInt('18446744073709551615');

const textEncoder: TextEncoder = new TextEncoder();
const textDecoder: TextDecoder = new TextDecoder();

function deserializeUnit(_sink: Sink): null {
  return null;
}

function serializeUnit(_value: null, sink: Sink): Sink {
  return sink;
}

function deserializeU8(sink: Sink): number {
  const value = sink.view.getUint8(sink.pos);
  sink.pos += 1;
  return value;
}

function serializeU8(value: number, sink: Sink): Sink {
  sink.reserve(1);
  sink.view.setUint8(sink.pos, value);
  sink.pos += 1;
  return sink;
}

function deserializeI8(sink: Sink): number {
  const value = sink.view.getInt8(sink.pos);
  sink.pos += 1;
  return value;
}

function serializeI8(value: number, sink: Sink): Sink {
  sink.reserve(1);
  sink.view.setInt8(sink.pos, value);
  sink.pos += 1;
  return sink;
}

function deserializeU16(sink: Sink): number {
  const value = sink.view.getUint16(sink.pos, true);
  sink.pos += 2;
  return value;
}

function serializeU16(value: number, sink: Sink): Sink {
  sink.reserve(2);
  sink.view.setUint16(sink.pos, value, true);
  sink.pos += 2;
  return sink;
}

function deserializeI16(sink: Sink): number {
  const value = sink.view.getInt16(sink.pos, true);
  sink.pos += 2;
  return value;
}

function serializeI16(value: number, sink: Sink): Sink {
  sink.reserve(2);
  sink.view.setInt16(sink.pos, value, true);
  sink.pos += 2;
  return sink;
}

function deserializeU32(sink: Sink): number {
  const value = sink.view.getUint32(sink.pos, true);
  sink.pos += 4;
  return value;
}

function serializeU32(value: number, sink: Sink): Sink {
  sink.reserve(4);
  sink.view.setUint32(sink.pos, value, true);
  sink.pos += 4;
  return sink;
}

function deserializeI32(sink: Sink): number {
  const value = sink.view.getInt32(sink.pos, true);
  sink.pos += 4;
  return value;
}

function serializeI32(value: number, sink: Sink): Sink {
  sink.reserve(4);
  sink.view.setInt32(sink.pos, value, true);
  sink.pos += 4;
  return sink;
}

function deserializeF32(sink: Sink): number {
  const value = sink.view.getFloat32(sink.pos, true);
  sink.pos += 4;
  return value;
}

function serializeF32(value: number, sink: Sink): Sink {
  sink.reserve(4);
  sink.view.setFloat32(sink.pos, value, true);
  sink.pos += 4;
  return sink;
}

function deserializeF64(sink: Sink): number {
  const value = sink.view.getFloat64(sink.pos, true);
  sink.pos += 8;
  return value;
}

function serializeF64(value: number, sink: Sink): Sink {
  sink.reserve(8);
  sink.view.setFloat64(sink.pos, value, true);
  sink.pos += 8;
  return sink;
}

function deserializeU64(sink: Sink): bigint {
  const high = deserializeU32(sink);
  const low = deserializeU32(sink);

  return (BigInt(low) << BIG_32) | BigInt(high);
}

function serializeU64(value: bigint, sink: Sink): Sink {
  const low = value & BIG_32Fs;
  const high = value >> BIG_32;

  serializeU32(Number(low), sink);
  serializeU32(Number(high), sink);
  return sink;
}

function deserializeI64(sink: Sink): bigint {
  const high = deserializeI32(sink);
  const low = deserializeI32(sink);

  return (BigInt(low) << BIG_32) | BigInt(high);
}

function serializeI64(value: bigint, sink: Sink): Sink {
  const low = value & BIG_32Fs;
  const high = value >> BIG_32;

  serializeI32(Number(low), sink);
  serializeI32(Number(high), sink);
  return sink;
}

function deserializeUSize(sink: Sink): bigint {
  return deserializeU64(sink);
}

function serializeUSize(value: bigint, sink: Sink): Sink {
  serializeU64(value, sink);
  return sink;
}

function deserializeISize(sink: Sink): bigint {
  return deserializeI64(sink);
}

function serializeISize(value: bigint, sink: Sink): Sink {
  serializeI64(value, sink);
  return sink;
}

function deserializeU128(sink: Sink): bigint {
  const high = deserializeU64(sink);
  const low = deserializeU64(sink);

  return (low << BIG_64) | high;
}

function serializeU128(value: bigint, sink: Sink): Sink {
  const low = value & BIG_64Fs;
  const high = value >> BIG_64;

  serializeU64(low, sink);
  serializeU64(high, sink);
  return sink;
}

function deserializeI128(sink: Sink): bigint {
  const high = deserializeI64(sink);
  const low = deserializeI64(sink);

  return (low << BIG_64) | high;
}

function serializeI128(value: bigint, sink: Sink): Sink {
  const low = value & BIG_64Fs;
  const high = value >> BIG_64;

  serializeI64(low, sink);
  serializeI64(high, sink);
  return sink;
}

function deserializeBool(sink: Sink): boolean {
  return deserializeU8(sink) == 1;
}

function serializeBool(value: boolean, sink: Sink): Sink {
  serializeU8(value ? 1 : 0, sink);
  return sink;
}

function serializeBytes(value: Uint8Array, sink: Sink): Sink {
  sink.reserve(value.length + 1);
  new Uint8Array(sink.view.buffer, sink.pos).set(value);
  sink.pos += value.length;
  return sink;
}

function deserializeBytes(sink: Sink, length: number): Uint8Array {
  const bytes = sink.view.buffer.slice(sink.pos, sink.pos + length);
  sink.pos += length;
  return new Uint8Array(bytes);
}

function serializeString(value: string, sink: Sink): Sink {
  const bytes = textEncoder.encode(value);
  serializeU64(BigInt(bytes.length), sink);
  serializeBytes(bytes, sink);
  return sink;
}

function deserializeString(sink: Sink): string {
  const length = deserializeU64(sink);
  const bytes = deserializeBytes(sink, Number(length));
  return textDecoder.decode(bytes);
}

function serializeOption<T>(
  serializeFunc: (value: T, sink: Sink) => Sink
): (value: T | undefined, sink: Sink) => Sink {
  return (value: T | undefined, sink: Sink) => {
    serializeBool(value != undefined, sink);

    if (value != undefined) {
      serializeFunc(value, sink);
    }

    return sink;
  };
}

function deserializeOption<T>(
  deserializeFunc: (sink: Sink) => T
): (sink: Sink) => T | undefined {
  return (sink: Sink) => {
    const some = deserializeBool(sink);
    if (!some) {
      return undefined;
    }

    return deserializeFunc(sink);
  };
}

function serializeSeq<T>(
  serializeFunc: (value: T, sink: Sink) => Sink
): (value: Array<T>, sink: Sink) => Sink {
  return (value: Array<T>, sink: Sink) => {
    serializeU64(BigInt(value.length), sink);

    for (const each of value) {
      serializeFunc(each, sink);
    }

    return sink;
  };
}

function deserializeSeq<T>(deserializeFunc: (sink: Sink) => T): (sink: Sink) => Array<T> {
  return (sink: Sink) => {
    const length = deserializeU64(sink);
    const output = new Array();

    for (var i = 0; i < length; i++) {
      output.push(deserializeFunc(sink));
    }

    return output;
  };
}

type TypedArray = ArrayLike<any> & {
  BYTES_PER_ELEMENT: number;
  readonly length: number;
  readonly buffer: ArrayBuffer;
  readonly byteLength: number;
  readonly byteOffset: number;
};

type TypedArrayConstructor<T> = {
  new (buffer: ArrayBuffer, offset?: number, length?: number): T;
  BYTES_PER_ELEMENT: number;
};

function serializeTypedArray<T extends TypedArray>(value: T, sink: Sink): Sink {
  serializeU64(BigInt(value.length), sink);

  serializeBytes(
    new Uint8Array(value.buffer.slice(value.byteOffset, value.byteLength)),
    sink
  );

  return sink;
}

function deserializeTypedArray<T extends TypedArray>(
  array_type: TypedArrayConstructor<T>
): (sink: Sink) => T {
  return (sink: Sink) => {
    const length = deserializeU64(sink);
    const bytes = deserializeBytes(sink, Number(length) * array_type.BYTES_PER_ELEMENT);
    return new array_type(bytes.buffer, 0, Number(length));
  };
}

function serializeMap<TK, TV>(
  serializeKeyFunc: (value: TK, sink: Sink) => Sink,
  serializeValueFunc: (value: TV, sink: Sink) => Sink
): (value: Map<TK, TV>, sink: Sink) => Sink {
  return (value: Map<TK, TV>, sink: Sink) => {
    serializeU64(BigInt(value.size), sink);

    value.forEach((v, k) => {
      serializeKeyFunc(k, sink);
      serializeValueFunc(v, sink);
    });

    return sink;
  };
}

function deserializeMap<TK, TV>(
  deserializeKeyFunc: (sink: Sink) => TK,
  deserializeValueFunc: (sink: Sink) => TV
): (sink: Sink) => Map<TK, TV> {
  return (sink: Sink) => {
    const length = deserializeU64(sink);
    const output = new Map();

    for (var i = 0; i < length; i++) {
      output.set(deserializeKeyFunc(sink), deserializeValueFunc(sink));
    }

    return output;
  };
}

function serializeTuple<T extends any[]>(
  ...serializeFns: Array<(value: any, sink: Sink) => Sink>
): (value: T, sink: Sink) => Sink {
  return (value: T, sink: Sink) => {
    for (let i = 0; i < serializeFns.length; i++) {
      serializeFns[i](value[i], sink);
    }

    return sink;
  };
}

function deserializeTuple<T extends any[]>(
  ...deserializeFns: Array<(sink: Sink) => any>
): (sink: Sink) => T {
  return (sink: Sink) => {
    const out = new Array();

    for (const deserializeFn of deserializeFns) {
      out.push(deserializeFn(sink));
    }

    return out as T;
  };
}

type Wildcard<MatchFull, Result> = Partial<MatchFull> & {
  _: () => Result;
};

type MatchObj<MatchFull, Result> = MatchFull | Wildcard<MatchFull, Result>;